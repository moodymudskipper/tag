% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/05_tag.R
\name{tag}
\alias{tag}
\alias{tag_adverb}
\title{Build a tag or a tag_adverb}
\usage{
tag(pattern, args = alist(), rm_args = character(0))

tag_adverb(pattern, args = alist(), rm_args = character(0))
}
\arguments{
\item{pattern}{an unquoted expression, describes what will be done to the naked call}

\item{args}{a pairlist (use \code{base::alist()} or \code{rlang::exprs()}) which will
be used as the formals of the built \code{tag} or as additional parameters of the
built \code{tag_adverb}}

\item{rm_args}{a character vector of formal names to remove from the the
input function}
}
\description{
\code{tag}s are essentially adverb factories, they build adverbs (also called
function operators) from a set of parameters. \code{tag_adverb}s are adverbs,
unlike \code{tag}s they take a function as a first parameter.
Both benefit from a special syntax using the \code{$} operator.
}
\section{Formalism}{

\code{tag}s are designed to be used intuitively and are best understood by
examples such as the one proposed below.

The output of a \code{tag} call is a \code{tag_adverb}. The output of a \code{tag_adverb}
call is called a manufactured function. The first argument of a \code{tag_adverb}
is called the input function.

The \code{args} argument becomes either the formals of a \code{tag} object or the
additional arguments of a \code{tag_adverb} object (the first being \code{f}). We
may refer to \code{args} as the \emph{new formals}.
}

\section{Syntax}{

The \code{$} syntax offers an intuitive and flexible alternative to the traditional
adverb syntax. \code{some_tag(tag_arg)$fun(fun_arg)} can be used instead of
\code{some_tag(tag_arg)(fun)(fun_arg)}.

When a parameter is not provided to the \code{tag} it is featured as a parameter
of its \code{tag_adverb} output so \code{some_tag(tag_arg)$fun(fun_arg)} can be written
\code{some_tag()(fun, tag_arg)(fun_arg)}.

When a parameter is not provided to the \code{tag_adverb}, it is featured as a
parameter of the manufactured function, so the latter call can be spelt
\code{some_tag()(fun)(fun_arg, tag_arg)}, which we'll often simply write
\code{some_tag$fun(fun_arg, tag_arg)}.

This forwarding of unused arguments mixed with the magic built into the
methods \code{$.tag} and \code{$.adverb} allows a lot of flexibility, and interesting
intermediate objects can be built to be used as shorthands or in functionals.
}

\section{Using patterns}{

The \code{pattern} argument is a representation of the body of the manufactured
function. It allows for short definitions of \code{tag}s and \code{tag_adverb}s thanks
to a set of objects that one can use in the definitions.

Available objects are :

\describe{
\item{\code{f}}{input function}
\item{\code{SCALL}}{unevaluated expression containing the naked input
function call, i.e. the way the function would have been called without
the tag or its arguments}
\item{\code{CALL}}{Same as \code{SCALL} but the arguments that were not named in the
call are named (unless they're part of the \code{...})}
\item{\code{CALL_UNEXP}}{Same as \code{CALL} but the \code{...} are \emph{NOT} expanded}
\item{\code{ARGS}}{List of the unevaluated arguments as given in the call,
identical to \code{CALL}}
\item{\code{FORMALS}}{List of the unevaluated arguments as given in the call}
\item{\code{NEW_FORMALS}}{The formals of the \code{tag}, or additional formals of
the \code{tag_adverb}}
}

\code{f} and \code{CALLS} suffice for most tag definitions.
}

\examples{
##################
# BUILDING A TAG #
##################

# this is the neutral tag, it doesn't do anything
identity_tag <- tag({eval(CALL)})
identity_tag$mean(c(1,2,NA,3), na.rm = TRUE)

# this tags gives informations about the call using all our shortcuts
verbosing <- tag(args = alist(descr="Here's a breakdown of the call"), {
 message(descr)
 cat("----------------------------------------------\\n")
 message("`f`: input function\\n")
 print(f)
 cat("----------------------------------------------\\n")
 message("`SCALL`: unevaluated expression containing the naked input function call\\n")
 print(SCALL)
 cat("----------------------------------------------\\n")
 message("`CALL`: Same as `SCALL` but the arguments that were not named in the call are named\\n")
 print(CALL)
 cat("----------------------------------------------\\n")
 message("`CALL_UNEXP`: Same as `CALL` but the `...` are *NOT* expanded\\n")
 print(CALL_UNEXP)
 cat("----------------------------------------------\\n")
 message("`ARGS`: List of the unevaluated arguments as given in the call, identical to `CALL`\\n")
 print(ARGS)
 cat("----------------------------------------------\\n")
 message("`FORMALS`: List of the unevaluated arguments as given in the call\\n")
 print(FORMALS)
 cat("----------------------------------------------\\n")
 message("`NEW_FORMALS`: The formals of the `tag`, or additional formals of the `tag_adverb`\\n")
 print(NEW_FORMALS)
 cat("----------------------------------------------\\n")
 message("`Now evaluating call:\\n")
 eval(CALL)
})

verbosing("See details below:")$mean(c(1,2,NA,3), na.rm = TRUE)

##########
# SYNTAX #
##########

# We build a copy of the `viewing` tag from the package `tags` and showcase
# the syntax.

# viewing2 tag to view the output of a call
viewing2 <- tag(args = alist(.title = "View"),{
  res <- eval(CALL)
  View(res,title = .title)
  res
})
\dontrun{
viewing2("A")(head)(cars, 2) # "A" is fed to the tag
class(viewing2)
class(viewing2("A"))
class(viewing2("A")(head))
viewing2("B")$head(cars, 2)              # equivalent, arguably more readable
viewing2()(head, "C")(cars, 2)           # "C" is fed to the tag_adverb
viewing2()(head)(cars, 2, .title = "D")  # "D" is fed to the manufactured function
viewing2()$head(cars, 2, .title = "E")   # "E" equivalent, a bit more readable
viewing2$head(cars, 2, .title = "F")     # equivalent, arguably more readable
}

#################
# MORE EXAMPLES #
#################
# these are copies of some simple tags that can be found in the package tags

# strictly2 tag to adjust strictness of a call
strictly2 <- tag(args = alist(warn=2),{
  w <- options("warn")[[1]]
  on.exit(options(warn=w))
  options(warn= warn)
  eval(CALL)
})
strictly2(-1)$sqrt(-1)

# dbg tag to debug a call
dbg2 <- tag({
  debugonce(f)
  exec("f", !!!purrr::map(ARGS, eval))
})
\dontrun{
  dbg2$sample(5)
}
}
